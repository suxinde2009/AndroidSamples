/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "demo_scene.hpp"
#include "game_asset_manager.hpp"
#include "imgui.h"
#include "imgui_manager.hpp"
#include "native_engine.hpp"
#include "texture_manager.hpp"

extern "C" {
#include <GLES2/gl2.h>
}

namespace {
    // Show ImGui demo window for testing purposes
    bool show_demo_window = false;

    static void LoadTexturesForAssetPack(GameAssetManager *gameAssetManager,
                                         const char *assetPackName, bool *texturesLoaded) {
        if (*texturesLoaded == false) {
            TextureManager *textureManager = NativeEngine::GetInstance()->GetTextureManager();

            int assetPackFileCount = 0;
            const char **assetPackFiles = gameAssetManager->GetGameAssetPackFileList(assetPackName,
                                                                                     &assetPackFileCount);
            if (assetPackFiles != NULL) {
                for (int i = 0; i < assetPackFileCount; ++i) {
                    if (textureManager->IsTextureLoaded(assetPackFiles[i]) == false) {
                        if (textureManager->LoadTexture(assetPackFiles[i])) {
                            LOGD("Loaded texture %s", assetPackFiles[i]);
                        } else {
                            LOGE("Failed to load texture %s", assetPackFiles[i]);
                        }
                    }
                }
            }
        }
        *texturesLoaded = true;
    }
}

DemoScene::DemoScene() {
    mPointerDown = false;
    mErrorScreen = false;
    mInstallTimeTexturesLoaded = false;
    mFastFollowTexturesLoaded = false;
    mOnDemandTexturesLoaded = false;
    mWaitScreen = DetermineWaitStatus();
    mTransitionStart = 0.0f;
    mPointerX = 0.0f;
    mPointerY = 0.0f;
    mCurrentTextureReference = TextureManager::INVALID_TEXTURE_REF;
}

DemoScene::~DemoScene() {
}

void DemoScene::OnStartGraphics() {
    mTransitionStart = Clock();
}

void DemoScene::OnKillGraphics() {
}

void DemoScene::OnScreenResized(int width, int height) {
}

void DemoScene::DoFrame() {
    // clear screen
    glClearColor(0.0f, 0.0f, 0.25f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDisable(GL_DEPTH_TEST);

    // Update UI inputs to ImGui before calling new frame
    UpdateUIInput();
    ImGuiManager *imguiManager = NativeEngine::GetInstance()->GetImGuiManager();
    imguiManager->BeginImGuiFrame();

    // Update the game asset manager
    NativeEngine::GetInstance()->GetGameAssetManager()->UpdateGameAssetManager();

    if (show_demo_window) {
        // showing the imgui demo screen for testing
        ImGui::ShowDemoWindow(&show_demo_window);
    } else if (mErrorScreen) {
        // if an asset error occurred, display the error ui and do nothing else
        DisplayErrorUI();
    } else if (mWaitScreen) {
        // if waiting for must-have assets, display the wait ui and do nothing else
        DisplayWaitUI();
    } else {
        DisplayMainUI();
    }

    imguiManager->EndImGuiFrame();
    glEnable(GL_DEPTH_TEST);
}

void DemoScene::RenderBackground() {
    // base classes override this to draw background
}

void DemoScene::OnButtonClicked(int buttonId) {
    // base classes override this to react to button clicks
}

void DemoScene::OnPointerDown(int pointerId, const struct PointerCoords *coords) {
    // If this event was generated by something that's not associated to the screen,
    // (like a trackpad), ignore it, because our UI is not driven that way.
    if (coords->isScreen) {
        mPointerDown = true;
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerMove(int pointerId, const struct PointerCoords *coords) {
    if (coords->isScreen && mPointerDown) {
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerUp(int pointerId, const struct PointerCoords *coords) {
    if (!coords->isScreen) {
        return;
    }

    mPointerX = coords->x;
    mPointerY = coords->y;
    mPointerDown = false;
}

bool DemoScene::DetermineWaitStatus() {
#if 0
    return false;
#else
    bool needToWait = true;

    GameAssetManager *gameAssetManager = NativeEngine::GetInstance()->GetGameAssetManager();
    const GameAssetManager::GameAssetStatus assetPackStatus = gameAssetManager->
            GetGameAssetPackStatus(FASTFOLLOW_ASSETPACK_NAME);
    needToWait = (assetPackStatus != GameAssetManager::GAMEASSET_READY);

    // Check if an error condition was set
    if (assetPackStatus == GameAssetManager::GAMEASSET_ERROR) {
        SetErrorScreen(true);
    }

    return needToWait;
#endif
}

void DemoScene::DisplayAssetPackDownloadStatus(GameAssetManager *gameAssetManager,
                                               const char *assetPackName) {
    float completionPercent = 0.0f;
    gameAssetManager->GetDownloadStatus(assetPackName, &completionPercent, NULL);
    const int displayPercent = static_cast<int>((completionPercent > 0.0f) ? 100.0f /
                                                                             completionPercent
                                                                           : 0.0f);
    ImGui::Text("Downloading pack %s (%d%%)", assetPackName, displayPercent);
    ImGui::ProgressBar(completionPercent);

    GameAssetManager::GameAssetPackType assetPackType = gameAssetManager->GetGameAssetPackType(
            assetPackName);
    if (assetPackType == GameAssetManager::GAMEASSET_PACKTYPE_ONDEMAND) {
        // On-demand asset packs can request download cancellation
        char cancelLabel[128];
        snprintf(cancelLabel, 128, "Cancel %s download", assetPackName);
        if (ImGui::Button(cancelLabel)) {
            gameAssetManager->RequestDownloadCancellation(assetPackName);
        }
    }
}

void DemoScene::DisplayAssetPackNeedsDownloadStatus(GameAssetManager *gameAssetManager,
                                                    const char *assetPackName) {
    ImGui::Text("Pack %s needs download", assetPackName);
    uint64_t assetPackSize = 0;
    gameAssetManager->GetDownloadStatus(assetPackName,
                                        NULL, &assetPackSize);
    const float assetPackSizeMB = ((float) assetPackSize) / (1024.0f * 1024.0f);
    char downloadLabel[128];
    snprintf(downloadLabel, 128, "Download %s %.1f MB", assetPackName, assetPackSizeMB);
    if (ImGui::Button(downloadLabel)) {
        gameAssetManager->RequestDownload(assetPackName);
    }
}

void DemoScene::DisplayAssetPackNeedsMobileAuthStatus(GameAssetManager *gameAssetManager,
                                                      const char *assetPackName) {
    ImGui::Text("Pack %s needs mobile data authorization", assetPackName);
    uint64_t assetPackSize = 0;
    gameAssetManager->GetDownloadStatus(assetPackName,
                                        NULL, &assetPackSize);
    const float assetPackSizeMB = ((float) assetPackSize) / (1024.0f * 1024.0f);
    char authLabel[128];
    snprintf(authLabel, 128, "Request Mobile Download %s %.1f MB", assetPackName, assetPackSizeMB);
    if (ImGui::Button(authLabel)) {
        gameAssetManager->RequestMobileDataDownloads();
    }
}

void DemoScene::DisplayAssetPackReadyStatus(GameAssetManager *gameAssetManager,
                                            const char *assetPackName, bool *texturesLoaded) {
    // Ensure textures from this asset pack are loaded and ready for use
    LoadTexturesForAssetPack(gameAssetManager, assetPackName, texturesLoaded);

    TextureManager *textureManager = NativeEngine::GetInstance()->GetTextureManager();
    ImGui::Text("Pack: %s available", assetPackName);
    int assetPackFileCount = 0;
    const char **assetPackFiles = gameAssetManager->GetGameAssetPackFileList(assetPackName,
                                                                             &assetPackFileCount);
    if (assetPackFiles != NULL) {
        for (int i = 0; i < assetPackFileCount; ++i) {
            if (ImGui::Button(assetPackFiles[i])) {
                mCurrentTextureReference = textureManager->GetTextureReference(assetPackFiles[i]);
            }
        }
    }

    const GameAssetManager::GameAssetPackType assetPackType = gameAssetManager->
            GetGameAssetPackType(assetPackName);
    if (assetPackType != GameAssetManager::GAMEASSET_PACKTYPE_INTERNAL) {
        // non-internal asset packs can request removal
        char removeLabel[128];
        snprintf(removeLabel, 128, "Remove %s", assetPackName);
        if (ImGui::Button(removeLabel)) {
            gameAssetManager->RequestRemoval(assetPackName);
        }
    }
}

void DemoScene::DisplayAssetPackUI(const char *assetPackName, bool *texturesLoaded) {
    GameAssetManager *gameAssetManager = NativeEngine::GetInstance()->GetGameAssetManager();
    const GameAssetManager::GameAssetStatus assetStatus = gameAssetManager->
            GetGameAssetPackStatus(assetPackName);
    ImGui::Separator();

    switch (assetStatus) {
        case GameAssetManager::GAMEASSET_NOT_FOUND:
            ImGui::Text("Pack not found: %s", assetPackName);
            break;
        case GameAssetManager::GAMEASSET_WAITING_FOR_STATUS:
            ImGui::Text("Waiting for status: %s", assetPackName);
            break;
        case GameAssetManager::GAMEASSET_NEEDS_DOWNLOAD:
            DisplayAssetPackNeedsDownloadStatus(gameAssetManager, assetPackName);
            break;
        case GameAssetManager::GAMEASSET_NEEDS_MOBILE_AUTH:
            DisplayAssetPackNeedsMobileAuthStatus(gameAssetManager, assetPackName);
            break;
        case GameAssetManager::GAMEASSET_DOWNLOADING:
            DisplayAssetPackDownloadStatus(gameAssetManager, assetPackName);
            break;
        case GameAssetManager::GAMEASSET_READY:
            DisplayAssetPackReadyStatus(gameAssetManager, assetPackName, texturesLoaded);
            break;
        case GameAssetManager::GAMEASSET_PENDING_ACTION:
            ImGui::Text("Waiting for pending action: %s", assetPackName);
            break;
        case GameAssetManager::GAMEASSET_ERROR:
            SetErrorScreen(true);
            break;
    }
}

void DemoScene::DisplayErrorUI() {
    GameAssetManager *gameAssetManager = NativeEngine::GetInstance()->GetGameAssetManager();
    const char *assetErrorString = gameAssetManager->GetGameAssetErrorMessage();
    DisplayUIHeader();
    ImGui::Text("Asset error:\n%s", assetErrorString);
    ImGui::End();
    ImGui::PopStyleVar();
}

void DemoScene::DisplayMainUI() {
    DisplayUIHeader();
    ImGui::Columns(2, NULL, false);
    DisplayAssetPackUI(INSTALL_ASSETPACK_NAME, &mInstallTimeTexturesLoaded);
    DisplayAssetPackUI(FASTFOLLOW_ASSETPACK_NAME, &mFastFollowTexturesLoaded);
    DisplayAssetPackUI(ONDEMAND_ASSETPACK_NAME, &mOnDemandTexturesLoaded);
    ImGui::NextColumn();
    if (mCurrentTextureReference != TextureManager::INVALID_TEXTURE_REF) {
        ImGui::SetCursorPosY(0.0f);
        float columnWidth = ImGui::GetColumnWidth();
        ImVec2 textureSize(columnWidth * 0.9f, columnWidth * 0.9f);
        ImGui::Image(reinterpret_cast<ImTextureID>(mCurrentTextureReference), textureSize);
    }
    ImGui::Columns(1);
    ImGui::End();
    ImGui::PopStyleVar();
}

void DemoScene::DisplayUIHeader() {
    ImGuiIO &io = ImGui::GetIO();
    ImVec2 windowPosition(0.0f, 0.0f);
    ImVec2 minWindowSize(io.DisplaySize.x * 0.95f, io.DisplaySize.y * 0.95f);
    ImVec2 maxWindowSize = io.DisplaySize;
    ImGui::SetNextWindowPos(windowPosition);
    ImGui::SetNextWindowSizeConstraints(minWindowSize, maxWindowSize, NULL, NULL);
    ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoResize |
                                   ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoMove;
    ImGui::PushStyleVar(ImGuiStyleVar_ScrollbarSize, 32.0f);
    const char *textureFormat =
            NativeEngine::GetInstance()->GetTextureManager()->GetTextureFormatInUse() ==
            TextureManager::TEXTUREFORMAT_ETC2 ? "ETC2" : "ASTC";
    char titleString[64];
    snprintf(titleString, 64, "Native PAD Demo (%s)", textureFormat);
    ImGui::Begin(titleString, NULL, windowFlags);
}

void DemoScene::DisplayWaitUI() {
    DisplayUIHeader();
    ImGui::Text("Waiting on fast-follow pack:");
    DisplayAssetPackUI(FASTFOLLOW_ASSETPACK_NAME, &mFastFollowTexturesLoaded);
    ImGui::End();
    ImGui::PopStyleVar();

    // Check if our wait has ended
    mWaitScreen = DetermineWaitStatus();

    // Check if we need to request cellular permission
    GameAssetManager *gameAssetManager = NativeEngine::GetInstance()->GetGameAssetManager();
    const GameAssetManager::GameAssetStatus assetStatus = gameAssetManager->
            GetGameAssetPackStatus(FASTFOLLOW_ASSETPACK_NAME);
    if (assetStatus == GameAssetManager::GAMEASSET_NEEDS_MOBILE_AUTH) {
        gameAssetManager->RequestMobileDataDownloads();
    }
}

void DemoScene::UpdateUIInput() {
    ImGuiIO &io = ImGui::GetIO();
    io.MouseDown[0] = mPointerDown;
    io.MousePos = ImVec2(mPointerX, mPointerY);
}
